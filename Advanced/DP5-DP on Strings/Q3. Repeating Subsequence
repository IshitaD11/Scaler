/* Q3. Repeating Subsequence

Problem Description
Given a string A, find if there is any subsequence that repeats itself.

A subsequence of a string is defined as a sequence of characters generated by deleting some characters in the string without changing the order of the remaining characters.

NOTE:
1. Subsequence length should be greater than or equal to 2.
2. The repeating subsequence should be disjoint that is in both the sequence no character in the same order and position should be taken from the same index of the original string.



Problem Constraints
1 <= length(A) <= 100



Input Format
The first and the only argument of input contains a string A.



Output Format
Return an integer, 1 if there is any subsequence which repeat itself else return 0.



Example Input
Input 1:

 A = "abab"
Input 2:

 A = "abba"


Example Output
Output 1:

 1
Output 2:

 0


Example Explanation
Explanation 1:

 "ab" is repeated.
Explanation 2:

 There is no repeating subsequence. */

//Idea is to match A with A and get their LCS (Longest common subsequnce). If LCS is >=2 then we have a repeating subsequnce in A.
// Here to get LCS(A,A) we need to skip for the same index. If idxA!=idxB then only try to match A[idxA] to B[idxB]

public class Solution {
    public int anytwo(String A) {
        int lenA=A.length();
        int [][] dp = new int[lenA][lenA];
        for(int i=0;i<lenA;i++)
            Arrays.fill(dp[i],-1);
        int len = subsequnce(A,A,lenA-1,lenA-1,dp);
        if(len>=2)
            return 1;
        return 0;
    }

    public int subsequnce(String A,String B,int idxA,int idxB,int[][] dp)
    {
        if(idxA<0 || idxB<0)
            return 0;
        
        if(dp[idxA][idxB]!=-1)
            return dp[idxA][idxB];
        
        int ans=0;
        if(idxA!=idxB && A.charAt(idxA)==B.charAt(idxB))
        {
            ans = subsequnce(A,B,idxA-1,idxB-1,dp)+1; 
            //char matches check for other chars to add to subsequnce lenth. +1 as char matches we can increase subsequnce lenth for current char
        }
        else
        {
            // check A[idxA] with B[idxB-1] and check A[idxA-1] with B[idxB] for matching
            int a = subsequnce(A,B,idxA-1,idxB,dp);
            int b = subsequnce(A,B,idxA,idxB-1,dp);
            ans = Math.max(a,b);
        }
        dp[idxA][idxB]=ans;
        return dp[idxA][idxB];
    }
}
